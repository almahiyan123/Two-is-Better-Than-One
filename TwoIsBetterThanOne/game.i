# 1 "game.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "game.c"
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 1 3
# 10 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/ieeefp.h" 1 3
# 11 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 1 3
# 15 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/newlib.h" 1 3
# 16 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 2 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/config.h" 1 3



# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/ieeefp.h" 1 3
# 5 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/config.h" 2 3
# 17 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 2 3
# 12 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3



# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 211 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int size_t;
# 323 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 16 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3

# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 1 3
# 13 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/_ansi.h" 1 3
# 14 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 2 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 1 3
# 12 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_types.h" 1 3






# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 1 3
# 26 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed char __int8_t ;
typedef unsigned char __uint8_t ;
# 36 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed short __int16_t;
typedef unsigned short __uint16_t;
# 46 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
# 58 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
# 76 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
# 99 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_default_types.h" 3
typedef signed long long __int64_t;
typedef unsigned long long __uint64_t;
# 8 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/_types.h" 2 3
# 13 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 14 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3


typedef long _off_t;







typedef int __dev_t;




typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;







typedef long _fpos_t;
# 56 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 3
typedef int _ssize_t;






# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 352 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 64 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 15 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 2 3






typedef unsigned long __ULong;
# 37 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 89 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 105 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 169 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                     ;
  int (* _write) (struct _reent *, void *, const char *, int)
                            ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  int _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 273 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 305 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 579 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;


  struct _atexit *_atexit;
  struct _atexit _atexit0;


  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 817 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);
# 18 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/stdlib.h" 1 3
# 19 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 2 3
# 27 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3


typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;
# 58 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
extern int __mb_cur_max;



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);



int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, int (* _compar) (const void *, const void *))



                                                         ;
void * calloc (size_t __nmemb, size_t __size) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *) ;
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);
long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) ;
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *, const char *, size_t);
int _mbtowc_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *, const char *, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *, const char *, size_t, _mbstate_t *);
size_t wcstombs (char *, const wchar_t *, size_t);
size_t _wcstombs_r (struct _reent *, char *, const wchar_t *, size_t, _mbstate_t *);
# 111 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
void qsort (void * __base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void *));
int rand (void);
void * realloc (void * __r, size_t __size) ;



void srand (unsigned __seed);
double strtod (const char *__n, char **__end_PTR);
double _strtod_r (struct _reent *,const char *__n, char **__end_PTR);
float strtof (const char *__n, char **__end_PTR);






long strtol (const char *__n, char **__end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__n, char **__end_PTR, int __base);
unsigned long strtoul (const char *__n, char **__end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__n, char **__end_PTR, int __base);

int system (const char *__string);
# 198 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdlib.h" 3
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);



extern long double strtold (const char *, char **);
extern long double wcstold (const wchar_t *, wchar_t **);



# 2 "game.c" 2
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/string.h" 1 3
# 14 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/string.h" 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 15 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/string.h" 2 3







void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void *, const void *, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *, const char *);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *, const char *);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *, const char *, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *, const char *, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);


char *strtok (char *, const char *);


size_t strxfrm (char *, const char *, size_t);
# 100 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/string.h" 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/string.h" 1 3
# 101 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/string.h" 2 3


# 3 "game.c" 2
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 1 3
# 34 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 35 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 2 3


# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stdarg.h" 1 3 4
# 40 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 38 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 2 3
# 46 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 1 3
# 69 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 1 3 4
# 149 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 70 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 2 3
# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/types.h" 1 3
# 19 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/machine/types.h" 3
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 71 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 2 3
# 92 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 3
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;



typedef unsigned short ushort;
typedef unsigned int uint;



typedef unsigned long clock_t;




typedef long time_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};


typedef long daddr_t;
typedef char * caddr_t;






typedef unsigned int ino_t;
# 162 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 3
typedef _off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;





typedef int pid_t;



typedef long key_t;

typedef _ssize_t ssize_t;
# 191 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 3
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;
# 218 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 3
typedef long fd_mask;







typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8))-1))/((sizeof (fd_mask) * 8)))];
} _types_fd_set;
# 249 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 3
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef unsigned long useconds_t;
typedef long suseconds_t;

typedef __uint32_t fsblkcnt_t;
typedef __uint32_t fsfilcnt_t;

# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/features.h" 1 3
# 265 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/types.h" 2 3
# 47 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 2 3



typedef __FILE FILE;
# 59 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 3
typedef _fpos_t fpos_t;





# 1 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/sys/stdio.h" 1 3
# 66 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 2 3
# 175 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);
int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *, const char *, FILE *);
void setbuf (FILE *, char *);
int setvbuf (FILE *, char *, int, size_t);
int fprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int printf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int scanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int sscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int vfprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int vsprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int fgetc (FILE *);
char * fgets (char *, int, FILE *);
int fputc (int, FILE *);
int fputs (const char *, FILE *);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *, size_t _size, size_t _n, FILE *);
size_t fwrite (const void * , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *, fpos_t *);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *_name, const char *_type);
int sprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int remove (const char *);
int rename (const char *, const char *);
# 246 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 3
int asiprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
char * asniprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * asnprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int asprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int diprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int fcloseall (void);
int fiprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fiscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int iprintf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int iscanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int siprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int siscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int snprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int sniprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * tempnam (const char *, const char *);
int vasiprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vasprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vdiprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vfscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int viprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int viscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vsiprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vsiscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vsniprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsnprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
# 361 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 3
int _asiprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
char * _asnprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _asprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _diprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _dprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *, int, FILE *);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fiscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
FILE * _fmemopen_r (struct _reent *, void *, size_t, const char *);
FILE * _fopen_r (struct _reent *, const char *, const char *);
FILE * _freopen_r (struct _reent *, const char *, const char *, FILE *);
int _fprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *, FILE *);
size_t _fread_r (struct _reent *, void *, size_t _size, size_t _n, FILE *);
int _fscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _fseek_r (struct _reent *, FILE *, long, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void * , size_t _size, size_t _n, FILE *);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _iscanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new)
                                          ;
int _scanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int _siprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _siscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _snprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _sprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _sscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vfprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _vscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsnprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 519 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 687 "c:\\devkitarm\\devkitarm\\bin\\../lib/gcc/arm-eabi/4.5.0/../../../../arm-eabi/include/stdio.h" 3

# 4 "game.c" 2
# 1 "game.h" 1




typedef struct{
 const unsigned char* data;
 int length;
 int frequency;
 int isPlaying;
 int loops;
 int duration;
 int priority;
 int vbCount;
}SOUND;

SOUND soundB;

void setupSounds();
void playSoundA( const unsigned char* sound, int length, int frequency, int loops);
void playSoundB( const unsigned char* sound, int length, int frequency, int loops);
void muteSound();
void unmuteSound();
void stopSound();

void setupInterrupts();
void interruptHandler();

typedef struct
{
 int screenRow;
 int screenCol;
 int height;
 int width;
 int rdel;
 int cdel;
 int aniCounter;
 int aniState;
 int prevAniState;
 int currFrame;
 int direction;
 int lives;
 int isHit;
} PLAYER;

typedef struct
{
 int screenRow;
 int screenCol;
 int width;
 int height;
 int size;
 int rdel;
 int cdel;
 int direction;
 int state;
 int stateCount;
 int lives;
 int active;
 int isHit;
} ENEMY;

typedef struct
{
 int screenRow;
 int screenCol;
 int cdel;
 int rdel;
 int direction;
 int width;
 int height;
 int active;
} BULLET;

typedef struct
{
 int screenRow;
 int screenCol;
 int cdel;
 int rdel;
 int width;
 int height;
 int active;
 int isHit;
} OBJECT;


void hideSprites();
void copyShadowOAM();

void gameFunctions();

void actPlayers(int);
void moveBullets(int);
void moveEnemies(int);
void moveObjects(int);

void playerCollisions();
void enemyCollisions();

void drawCharacters();
void drawEnemies();
void drawBullets();
void drawObjects();


void swapPlayers();

void actFighter();
void actionsFighter();
void actFighterWithBlock();
void actShooter();
void actionsShooter();
void moveFighter();
void moveShooter();
void moveOrb1();
void moveOrb2();
void movePBullets(int);
void moveTBullets();
void moveT2Bullets();
void moveBlock();
void moveBlockTut4();
void moveBlockGame2();
void moveOrb1Game2();
void moveOrb2Game2();


void actTut1Shooter();
void actTut1Fighter();
void moveTut1Shooter();
void moveTut1Fighter();
void moveTut3Fighter();
void moveTut4Fighter();
void moveTut7Shooter();
void moveGame2Shooter();
void moveGame2Fighter();


int playerEnemyCollision();
int playerObjectCollision(int, int, int, int, int, int, int, int);
int playerBulletCollision(int, int, int, int, int, int, int, int);
int enemyBulletCollision();
void door1Collision(int);
void door2Collision(int);
void wallCollision();
void blockCollision();
void chestCollision();
void leverCollision();
void wall2Collision();


int genericCollision(int colA, int rowA, int heightA, int widthA, int colB, int rowB, int heightB, int widthB);

int checkNoLives();
int checkWin();

void drawFighter();
void drawShooter();
void drawPBullets();
void drawOrb1();
void drawOrb2();
void drawTBullets();
void drawBlock();
void drawChest();
void drawDoor1();
void drawDoor2();
void drawWall();
void drawWall2();
void drawLever();
void drawButton();
void updateLives();
# 5 "game.c" 2
# 1 "myLib.h" 1



typedef unsigned short u16;
# 41 "myLib.h"
extern unsigned short *videoBuffer;

extern unsigned short *frontBuffer;
extern unsigned short *backBuffer;



void loadPalette(const unsigned short* palette);
void initialize(int);

void waitForVblank();
void flipPage();
# 73 "myLib.h"
extern unsigned int oldButtons;
extern unsigned int buttons;
# 83 "myLib.h"
void DMANow(int channel, volatile const void* source, volatile void* destination, unsigned int control);






typedef volatile struct
{
        volatile const void *src;
        volatile void *dst;
        volatile unsigned int cnt;
} DMA;

extern DMA *dma;
# 212 "myLib.h"
typedef struct { u16 tileimg[8192]; } charblock;
typedef struct { u16 tilemap[1024]; } screenblock;
# 298 "myLib.h"
typedef struct{
    unsigned short attr0;
    unsigned short attr1;
    unsigned short attr2;
    unsigned short fill;
}OBJ_ATTR;

typedef struct {
    int row;
    int col;
} Sprite;
# 6 "game.c" 2
# 1 "spritesheet.h" 1
# 21 "spritesheet.h"
extern const unsigned short spritesheetTiles[16384];


extern const unsigned short spritesheetPal[256];
# 7 "game.c" 2
# 1 "game_bg.h" 1
# 22 "game_bg.h"
extern const unsigned short game_bgTiles[1104];


extern const unsigned short game_bgMap[1024];


extern const unsigned short game_bgPal[256];
# 8 "game.c" 2
# 1 "collisionMap.h" 1
# 20 "collisionMap.h"
extern const unsigned short collisionMapBitmap[65536];
# 9 "game.c" 2
# 1 "collisionMapTut3.h" 1
# 20 "collisionMapTut3.h"
extern const unsigned short collisionMapTut3Bitmap[65536];
# 10 "game.c" 2
# 1 "collisionMapTut4.h" 1
# 20 "collisionMapTut4.h"
extern const unsigned short collisionMapTut4Bitmap[65536];
# 11 "game.c" 2
# 1 "collisionMapTut7.h" 1
# 20 "collisionMapTut7.h"
extern const unsigned short collisionMapTut7Bitmap[65536];
# 12 "game.c" 2
# 1 "collisionMap2.h" 1
# 20 "collisionMap2.h"
extern const unsigned short collisionMap2Bitmap[65536];
# 13 "game.c" 2
# 1 "GameSong.h" 1
# 20 "GameSong.h"
extern const unsigned char GameSong[453475];
# 14 "game.c" 2
# 1 "TitleSong.h" 1
# 20 "TitleSong.h"
extern const unsigned char TitleSong[314120];
# 15 "game.c" 2
# 1 "PunchSfx.h" 1
# 20 "PunchSfx.h"
extern const unsigned char PunchSfx[4041];
# 16 "game.c" 2
# 1 "LaserSfx.h" 1
# 20 "LaserSfx.h"
extern const unsigned char LaserSfx[3007];
# 17 "game.c" 2
# 1 "DoorSfx.h" 1
# 20 "DoorSfx.h"
extern const unsigned char DoorSfx[3925];
# 18 "game.c" 2
# 1 "OpenSfx.h" 1
# 20 "OpenSfx.h"
extern const unsigned char OpenSfx[5675];
# 19 "game.c" 2
# 1 "DestroySfx.h" 1
# 20 "DestroySfx.h"
extern const unsigned char DestroySfx[24236];
# 20 "game.c" 2
# 1 "SwitchSfx.h" 1
# 20 "SwitchSfx.h"
extern const unsigned char SwitchSfx[3070];
# 21 "game.c" 2
# 1 "DamageSfx.h" 1
# 20 "DamageSfx.h"
extern const unsigned char DamageSfx[5035];
# 22 "game.c" 2




int mapSize = 256;


OBJ_ATTR shadowOAM[128];


int screenCollMapSize = 256;





PLAYER fighter;
PLAYER shooter;

ENEMY orb1;
ENEMY orb2;


OBJECT block;
OBJECT wall;
OBJECT wall2;
OBJECT button;
OBJECT doorA;
OBJECT doorExit;
OBJECT chest;
int isChestOpen = 0;
OBJECT lever;
OBJECT livesNum;

int doorClosedRow = 0;
int doorOpenRow = 4;
int doorAloc = 12;
int doorExitloc = 8;

int blueDoorOpened = 0;
int greenDoorOpened = 0;


int onOffObjectLoc = 26;
int blockButton_loc = 28;


int wallOK = 16;
int wallDown = 16;
int wallTwoOk = 20;
int wallTwoDown = 20;
int chestClosed = 14;
int chestOpen = 16;
int leverOff = 18;
int leverOn = 20;
int blockloc = 8;
int buttonUp = 12;
int buttonDown = 10;

int withBlock = 0;



int bulletCount = 5;
int tBulletCount = 35;
int timeToNextTBullet;
int time;

int cheatPressed = 0;
int dontPunch = 0;

BULLET pBullets[5];
BULLET tBullets[35];


int bullet_loc = 24;
int bullet_h = 0;
int bullet_v = 2;
int tbullet_h = 4;
int tbullet_v = 6;


int which = 0;


int F_LEFT = 0;
int F_RIGHT = 1;
int F_DOWN = 2;
int F_UP = 3;
int S_LEFT = 4;
int S_RIGHT = 5;
int S_DOWN = 6;
int S_UP = 7;


int E_RIGHT = 8;
int E_UP = 9;
int E_LEFT = 10;
int E_DOWN = 11;

int orb_loc = 28;


int ifAttack = 0;
int ifOpenChest = 0;
int F_ATTACK = 12;
int S_ATTACK = 20;
int S_HACK = 22;

int withKey = 0;





enum {FRONT, BACK, RIGHT, LEFT, IDLE, ACT, ACT1, ACT2, BULLETSTART};


void copyShadowOAM(){
 DMANow(3, shadowOAM, ((OBJ_ATTR*)(0x7000000)), 4*128);
}


void hideSprites()
{
    for(int i = 0; i<128; i++){
     shadowOAM[i].attr0 = (2 << 8);
 }
}


void initialize(int tutLevel){



    cheatPressed = 0;

    if(tutLevel == 6 || tutLevel == 7){
        which = 1;
    }else{
        which = 0;
    }

    fighter.width = 11;
    fighter.height = 16;
    fighter.rdel = 1;
    fighter.cdel = 1;
    if(tutLevel == 1){
        fighter.screenRow = 80;
        fighter.screenCol = 120;
    }else if(tutLevel == 3){
        fighter.screenRow = 80;
        fighter.screenCol = 40;

    }else if(tutLevel == 4){
        fighter.screenRow = 90;
        fighter.screenCol = 10;

    }else if(tutLevel == 10){
        fighter.screenRow = 7;
        fighter.screenCol = 20;
    }else{
        fighter.screenRow = 130;
        fighter.screenCol = 20;
    }

    fighter.lives = 10;
    fighter.isHit = 0;

    fighter.aniState = FRONT;



    shooter.width = 8;
    shooter.height = 16;
    shooter.rdel = 1;
    shooter.cdel = 1;
    if(tutLevel == 1){
        shooter.screenRow = 80;
        shooter.screenCol = 120;
    }else if(tutLevel == 3 || tutLevel == 6){
        shooter.screenRow = 80;
        shooter.screenCol = 40;
    }else if(tutLevel == 4){
        shooter.screenRow = 90;
        shooter.screenCol = 10;
    }else if(tutLevel == 7){
        shooter.screenRow = 80;
        shooter.screenCol = 60;
    }else if(tutLevel == 10){
        shooter.screenRow = 7;
        shooter.screenRow = 20;
    }else{
        shooter.screenRow = 130;
        shooter.screenCol = 20;
    }

    shooter.lives = 5;
    shooter.isHit = 0;



    shooter.aniState = FRONT;

    fighter.aniCounter = 0;
    fighter.currFrame = 0;

    shooter.aniCounter = 0;
    shooter.currFrame = 0;

    orb1.state = IDLE;
    orb1.stateCount = 0;
    orb1.direction = E_DOWN;

    orb2.state = IDLE;
    orb2.stateCount = 0;
    orb2.direction = E_RIGHT;

    if(tutLevel == 10){
        orb1.screenRow = 90;
        orb1.screenCol = 200;
    }else{
        orb1.screenRow = 100;
         orb1.screenCol = 59;
    }

    orb1.width = 16;
    orb1.height = 16;
    orb1.cdel = 2;
    orb1.rdel = 2;
    orb1.active = 1;
    orb1.lives = 5;
    if(tutLevel == 6){
        orb2.screenRow = 90;
        orb2.screenCol = 150;
    }else if(tutLevel == 10){
        orb2.screenRow = 110;
        orb2.screenCol = 200;
    }else{
        orb2.screenRow = 10;
        orb2.screenCol = 180;
    }

    orb2.width = 16;
    orb2.height = 16;
    orb2.cdel = 1;
    orb2.rdel = 1;
    orb2.lives = 5;
    orb2.active = 1;

    livesNum.width = 10;
    livesNum.height = 14;
    if(tutLevel == 10){
        livesNum.screenRow = 103;
        livesNum.screenCol = 185;
    }else{
        livesNum.screenRow = 75;
        livesNum.screenCol = 138;
    }



    BULLET pBullet;
    pBullet.height = 4;
    pBullet.width = 4;
    pBullet.cdel = 0;
    pBullet.rdel = 0;
    pBullet.active = 0;

    for(int i = 0; i<bulletCount; i++){
        pBullets[i] = pBullet;
    }

    BULLET tBullet;
    tBullet.height = 4;
    tBullet.width = 4;
    tBullet.cdel = 0;
    tBullet.rdel = 0;
    tBullet.active = 0;


    for(int i = 0; i<tBulletCount; i++){
        tBullets[i] = tBullet;
    }

    if(tutLevel == 4){
        block.screenRow = 90;
        block.screenCol = 50;
    }else if(tutLevel == 10){
        block.screenRow = 45;
        block.screenCol = 65;
    }else{
        block.screenRow = 130;
        block.screenCol = 90;
    }

    block.height = 15;
    block.width = 15;
    block.cdel = 0;
    block.rdel = 0;

    doorA.height = 4;
    doorA.width = 23;
    if(tutLevel == 4){
        doorA.screenRow = 80;
        doorA.screenCol = 136;
    }else if(tutLevel == 10){
        doorA.screenRow = 40;
        doorA.screenCol = 200;
    }else{
        doorA.screenRow = 38;
        doorA.screenCol = 8;
    }

    doorA.active = 0;


    doorExit.height = 4;
    doorExit.width = 32;
    if(tutLevel == 7){
        doorExit.screenRow = 107;
        doorExit.screenCol = 184;
    }else if(tutLevel == 10){
        doorExit.screenRow = 130;
        doorExit.screenCol = 88;
    }else{
        doorExit.screenRow = 135;
        doorExit.screenCol = 202;
    }

    doorExit.active = 0;

    wall.height = 8;
    wall.width = 32;
    if(tutLevel == 10){
        wall.screenRow = 80;
        wall.screenCol = 88;
    }else{
         wall.screenRow = 119;
        wall.screenCol = 8;
    }

    wall.isHit = 0;
    wall.active = 0;


    wall2.height = 32;
    wall2.width = 8;
    if(tutLevel == 3){
         wall2.screenRow = 70;
         wall2.screenCol = 128;
    }else if(tutLevel == 10){
        wall2.screenRow = 130;
        wall2.screenCol = 48;
    }else{
        wall2.screenRow = 8;
        wall2.screenCol = 144;
    }

    wall2.isHit = 0;
    wall2.active = 0;

    chest.height = 13;
    chest.width = 14;
    if(tutLevel == 7){
        chest.screenRow = 76;
        chest.screenCol = 130;
    }else if(tutLevel == 10){
        chest.screenRow = 135;
        chest.screenCol = 60;
    }else{
        chest.screenRow = 17;
        chest.screenCol = 216;
    }

    chest.isHit = 0;
    chest.active = 0;

    lever.height = 8;
    lever.width = 8;
    if(tutLevel == 7){
        lever.screenRow = 75;
        lever.screenCol = 0;
    }else if(tutLevel == 10){
        lever.screenRow = 17;
        lever.screenCol = 200;
    }else{
        lever.screenRow = 15;
        lever.screenCol = 7;
    }

    lever.isHit = 0;
    lever.active = 0;

    button.height = 9;
    button.width = 9;
    if(tutLevel == 4){
         button.screenRow = 90;
         button.screenCol = 100;
    }else if(tutLevel == 10){
         button.screenRow = 138;
         button.screenCol = 137;
    }else{
         button.screenRow = 138;
         button.screenCol = 179;
    }

    button.active = 0;
    withKey = 0;
    blueDoorOpened = 0;

}


void swapPlayers(){
    which++;
    if(which == 2){
        which = 0;
    }
}


void actPlayers(int tutLevel){

    int tempCol;
    int tempRow;




    if(tutLevel != 3 && tutLevel != 4 && tutLevel !=6 && tutLevel !=7 && withKey != 1){
            if((!(~(oldButtons)&((1<<9))) && (~buttons & ((1<<9))))){
            playSoundB(SwitchSfx, 2000, 11025, 0);
            if(which == 0){
                tempCol = shooter.screenCol;
                shooter.screenCol = fighter.screenCol;
                fighter.screenCol = tempCol;

                tempRow = shooter.screenRow;
                shooter.screenRow = fighter.screenRow;
                fighter.screenRow = tempRow;

            }
            if(which == 1){
                tempCol = fighter.screenCol;
                fighter.screenCol = shooter.screenCol;
                shooter.screenCol = tempCol;

                tempRow = fighter.screenRow;
                fighter.screenRow = shooter.screenRow;
                shooter.screenRow = tempRow;
            }


            swapPlayers();

        }
    }



    if(tutLevel == 1){
        actTut1Shooter();
        actTut1Fighter();
        moveTut1Shooter();
        moveTut1Fighter();
    }else if(tutLevel == 3){
        actionsFighter();
        moveTut3Fighter();
    }else if(tutLevel == 4){
        actionsFighter();
        moveTut4Fighter();
    }else if(tutLevel == 6){
        actionsShooter();
        moveTut1Shooter();
    }else if(tutLevel == 7){
        actionsShooter();
        moveTut7Shooter();
    }else if(tutLevel == 10){
        actShooter();
        actFighter();
        moveGame2Shooter();
        moveGame2Fighter();
    }else{
        actShooter();
        actFighter();
        moveShooter();
        moveFighter();
    }



}

void actTut1Fighter(){
    actionsFighter();
}

void actTut1Shooter(){
    actionsShooter();
}

void moveTut1Fighter(){
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
          if(fighter.screenRow > 0){
            fighter.screenRow--;
        }
     }
     if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
           if(fighter.screenRow < 160 - fighter.height){
            fighter.screenRow++;
        }
 }
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
         if(fighter.screenCol> 0){
               fighter.screenCol--;
           }
     }
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
           if(fighter.screenCol< 240){
             fighter.screenCol++;
               }
        }
}

void moveTut3Fighter(){
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
        if(!collisionMapTut3Bitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol +3))] == 0
            && !collisionMapTut3Bitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol + fighter.width/2 +3))] == 0
                && !collisionMapTut3Bitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol + fighter.width -2))] == 0)
                {

                    if(!wall2.active){
                        wall2Collision();
                    }


                    if(fighter.screenRow > 0){
                        fighter.screenRow--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
        if(!collisionMapTut3Bitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol +3))] == 0
             && !collisionMapTut3Bitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol + fighter.width/2 +3))] == 0
                && !collisionMapTut3Bitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol + fighter.width - 2))] == 0)
                {
                    if(!wall2.active){
                        wall2Collision();
                    }

                    if(fighter.screenRow < 160 - fighter.height){
                        fighter.screenRow++;
                    }

                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
        if(!collisionMapTut3Bitmap[((fighter.screenRow + 5)*(256)+(fighter.screenCol + 2))] == 0
            && !collisionMapTut3Bitmap[((fighter.screenRow + fighter.height/2)*(256)+(fighter.screenCol + 2))] == 0
                && !collisionMapTut3Bitmap[((fighter.screenRow + fighter.height - 1)*(256)+(fighter.screenCol + 2))] == 0)
                {

                    if(!wall2.active){
                        wall2Collision();
                    }

                    if(fighter.screenCol> 0){
                        fighter.screenCol--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
        if(!collisionMapTut3Bitmap[((fighter.screenRow + 5)*(256)+(fighter.screenCol + fighter.width - 1))] == 0
        && !collisionMapTut3Bitmap[((fighter.screenRow + fighter.height/2)*(256)+(fighter.screenCol + fighter.width - 1))] == 0
                && !collisionMapTut3Bitmap[((fighter.screenRow + fighter.height - 1)*(256)+(fighter.screenCol + fighter.width - 1))] == 0)
                {

                    if(!wall2.active){
                        wall2Collision();
                    }

                    if(fighter.screenCol< 240){
                        fighter.screenCol++;
                    }
                }
         }
}

void moveTut4Fighter(){
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
        if(!collisionMapTut4Bitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol +3))] == 0
            && !collisionMapTut4Bitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol + fighter.width/2 +3))] == 0
                && !collisionMapTut4Bitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol + fighter.width -2))] == 0)
                {

                    door1Collision(4);
                    if(fighter.screenRow > 0){
                        fighter.screenRow--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
        if(!collisionMapTut4Bitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol +3))] == 0
             && !collisionMapTut4Bitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol + fighter.width/2 +3))] == 0
                && !collisionMapTut4Bitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol + fighter.width - 2))] == 0)
                {

                    door1Collision(4);
                    if(fighter.screenRow < 160 - fighter.height){
                        fighter.screenRow++;
                    }

                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
        if(!collisionMapTut4Bitmap[((fighter.screenRow + 5)*(256)+(fighter.screenCol + 2))] == 0
            && !collisionMapTut4Bitmap[((fighter.screenRow + fighter.height/2)*(256)+(fighter.screenCol + 2))] == 0
                && !collisionMapTut4Bitmap[((fighter.screenRow + fighter.height - 1)*(256)+(fighter.screenCol + 2))] == 0)
                {

                    door1Collision(4);
                    if(fighter.screenCol> 0){
                        fighter.screenCol--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
        if(!collisionMapTut4Bitmap[((fighter.screenRow + 5)*(256)+(fighter.screenCol + fighter.width - 1))] == 0
        && !collisionMapTut4Bitmap[((fighter.screenRow + fighter.height/2)*(256)+(fighter.screenCol + fighter.width - 1))] == 0
                && !collisionMapTut4Bitmap[((fighter.screenRow + fighter.height - 1)*(256)+(fighter.screenCol + fighter.width - 1))] == 0)
                {

                    door1Collision(4);
                    if(fighter.screenCol< 240){
                        fighter.screenCol++;
                    }
                }
         }
}

void moveGame2Fighter(){
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
        if(!collisionMap2Bitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol +3))] == 0
            && !collisionMap2Bitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol + fighter.width/2 +3))] == 0
                && !collisionMap2Bitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol + fighter.width -2))] == 0)
                {
                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }

                    door1Collision(0);
                    door2Collision(0);
                    if(fighter.screenRow > 0){
                        fighter.screenRow--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
        if(!collisionMap2Bitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol +3))] == 0
             && !collisionMap2Bitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol + fighter.width/2 +3))] == 0
                && !collisionMap2Bitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol + fighter.width - 2))] == 0)
                {
                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                     door1Collision(0);
                    door2Collision(0);

                    if(fighter.screenRow < 160 - fighter.height){
                        fighter.screenRow++;
                    }

                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
        if(!collisionMap2Bitmap[((fighter.screenRow + 5)*(256)+(fighter.screenCol + 2))] == 0
            && !collisionMap2Bitmap[((fighter.screenRow + fighter.height/2)*(256)+(fighter.screenCol + 2))] == 0
                && !collisionMap2Bitmap[((fighter.screenRow + fighter.height - 1)*(256)+(fighter.screenCol + 2))] == 0)
                {
                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                     door1Collision(0);
                    door2Collision(0);
                    leverCollision();
                    if(fighter.screenCol> 0){
                        fighter.screenCol--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
        if(!collisionMap2Bitmap[((fighter.screenRow + 5)*(256)+(fighter.screenCol + fighter.width - 1))] == 0
        && !collisionMap2Bitmap[((fighter.screenRow + fighter.height/2)*(256)+(fighter.screenCol + fighter.width - 1))] == 0
                && !collisionMap2Bitmap[((fighter.screenRow + fighter.height - 1)*(256)+(fighter.screenCol + fighter.width - 1))] == 0)
                {
                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    chestCollision();
                    if(fighter.screenCol< 240){
                        fighter.screenCol++;
                    }
                }
         }
}

void moveTut1Shooter(){
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
          if(shooter.screenRow > 0){
            shooter.screenRow--;
        }
     }
     if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
           if(shooter.screenRow < 160 - shooter.height){
            shooter.screenRow++;
        }
 }
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
         if(shooter.screenCol> 0){
               shooter.screenCol--;
           }
     }
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
           if(shooter.screenCol< 240){
             shooter.screenCol++;
               }
            }
}

void moveTut6Shooter(){
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
          if(shooter.screenRow > 0){
            shooter.screenRow--;
        }
     }
     if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
           if(shooter.screenRow < 160 - shooter.height){
            shooter.screenRow++;
        }
    }
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
         if(shooter.screenCol> 0){
               shooter.screenCol--;
           }
     }
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
           if(shooter.screenCol< 240){
             shooter.screenCol++;
               }
            }
}

void moveTut7Shooter(){
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
        if(!collisionMapTut7Bitmap[((shooter.screenRow + 4)*(256)+(shooter.screenCol + 5))] == 0
            && !collisionMapTut7Bitmap[((shooter.screenRow + 4)*(256)+(shooter.screenCol + shooter.width/2 + 3))] == 0
                && !collisionMapTut7Bitmap[((shooter.screenRow + 4)*(256)+(shooter.screenCol + shooter.width - 1))] == 0)
                {

                    door2Collision(7);
                    if(shooter.screenRow > 0){
                        shooter.screenRow--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
        if(!collisionMapTut7Bitmap[((shooter.screenRow + shooter.height)*(256)+(shooter.screenCol + 5))] == 0
            && !collisionMapTut7Bitmap[((shooter.screenRow + shooter.height)*(256)+(shooter.screenCol + shooter.width/2 + 3))] == 0
                && !collisionMapTut7Bitmap[((shooter.screenRow + shooter.height)*(256)+(shooter.screenCol + shooter.width - 1))] == 0)
                {

                    door2Collision(7);
                    if(shooter.screenRow < 160 - shooter.height){
                        shooter.screenRow++;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
        if(!collisionMapTut7Bitmap[((shooter.screenRow + 5)*(256)+(shooter.screenCol + 4))] == 0
            && !collisionMapTut7Bitmap[((shooter.screenRow + shooter.height/2)*(256)+(shooter.screenCol + 4))] == 0
                && !collisionMapTut7Bitmap[((shooter.screenRow + shooter.height -1)*(256)+(shooter.screenCol + 4))] == 0)
                {

                    door2Collision(7);
                    leverCollision();
                    if(shooter.screenCol> 0){
                        shooter.screenCol--;
                    }
                }
         }
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
        if(!collisionMapTut7Bitmap[((shooter.screenRow + 5)*(256)+(shooter.screenCol + shooter.width))] == 0
            && !collisionMapTut7Bitmap[((shooter.screenRow + shooter.height/2)*(256)+(shooter.screenCol + shooter.width))] == 0
                && !collisionMapTut7Bitmap[((shooter.screenRow + shooter.height - 1)*(256)+(shooter.screenCol + shooter.width))] == 0)
                {

                    door2Collision(7);
                    chestCollision();
                    if(shooter.screenCol< 240){
                        shooter.screenCol++;
                    }
                }
         }
}

void moveGame2Shooter(){
     if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
        if(!collisionMap2Bitmap[((shooter.screenRow + 4)*(256)+(shooter.screenCol + 5))] == 0
            && !collisionMap2Bitmap[((shooter.screenRow + 4)*(256)+(shooter.screenCol + shooter.width/2 + 3))] == 0
                && !collisionMap2Bitmap[((shooter.screenRow + 4)*(256)+(shooter.screenCol + shooter.width - 1))] == 0)
                {

                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    if(shooter.screenRow > 0){
                        shooter.screenRow--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
        if(!collisionMap2Bitmap[((shooter.screenRow + shooter.height)*(256)+(shooter.screenCol + 5))] == 0
            && !collisionMap2Bitmap[((shooter.screenRow + shooter.height)*(256)+(shooter.screenCol + shooter.width/2 + 3))] == 0
                && !collisionMap2Bitmap[((shooter.screenRow + shooter.height)*(256)+(shooter.screenCol + shooter.width - 1))] == 0)
                {

                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    if(shooter.screenRow < 160 - shooter.height){
                        shooter.screenRow++;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
        if(!collisionMap2Bitmap[((shooter.screenRow + 5)*(256)+(shooter.screenCol + 4))] == 0
            && !collisionMap2Bitmap[((shooter.screenRow + shooter.height/2)*(256)+(shooter.screenCol + 4))] == 0
                && !collisionMap2Bitmap[((shooter.screenRow + shooter.height -1)*(256)+(shooter.screenCol + 4))] == 0)
                {

                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    leverCollision();
                    if(shooter.screenCol> 0){
                        shooter.screenCol--;
                    }
                }
         }
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
        if(!collisionMap2Bitmap[((shooter.screenRow + 5)*(256)+(shooter.screenCol + shooter.width))] == 0
            && !collisionMap2Bitmap[((shooter.screenRow + shooter.height/2)*(256)+(shooter.screenCol + shooter.width))] == 0
                && !collisionMap2Bitmap[((shooter.screenRow + shooter.height - 1)*(256)+(shooter.screenCol + shooter.width))] == 0)
                {

                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    chestCollision();
                    if(shooter.screenCol< 240){
                        shooter.screenCol++;
                    }
                }
         }
}



void moveEnemies(int tutLevel){

    if(tutLevel == 10){
        if(orb1.active){
            moveOrb1Game2();
        }
        if(orb2.active){
            moveOrb2Game2();
        }

    }else{
             if(tutLevel != 6){
            if(orb1.active){
                moveOrb1();
            }
        }


        if(orb2.active){
            moveOrb2();
        }
    }





    if((!(~(oldButtons)&((1<<8))) && (~buttons & ((1<<8))))){

        orb1.active = 0;
        orb2.active = 0;
        wall.active = 1;
        wall2.active = 1;
        if(cheatPressed == 0){
            playSoundB(DestroySfx, 24236, 11025, 0);
            cheatPressed = 1;
        }


    }
}




void moveBullets(int tutLevel){

    if(tutLevel == 10){
        moveT2Bullets();
        movePBullets(10);
    }else{
        movePBullets(0);
        moveTBullets(0);
    }

}

void moveObjects(int tutLevel){
    if(which != 1){
        if(tutLevel == 4){
            moveBlockTut4();
        }else if(tutLevel == 10){
            moveBlockGame2();
        }else{
            moveBlock();
        }

    }


}

void moveFighter(){

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
        if(!collisionMapBitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol +3))] == 0
            && !collisionMapBitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol + fighter.width/2 +3))] == 0
                && !collisionMapBitmap[((fighter.screenRow + 4)*(256)+(fighter.screenCol + fighter.width -2))] == 0)
                {
                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }

                    door1Collision(0);
                    door2Collision(0);
                    if(fighter.screenRow > 0){
                        fighter.screenRow--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
        if(!collisionMapBitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol +3))] == 0
             && !collisionMapBitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol + fighter.width/2 +3))] == 0
                && !collisionMapBitmap[((fighter.screenRow + fighter.height)*(256)+(fighter.screenCol + fighter.width - 2))] == 0)
                {
                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                     door1Collision(0);
                    door2Collision(0);

                    if(fighter.screenRow < 160 - fighter.height){
                        fighter.screenRow++;
                    }

                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
        if(!collisionMapBitmap[((fighter.screenRow + 5)*(256)+(fighter.screenCol + 2))] == 0
            && !collisionMapBitmap[((fighter.screenRow + fighter.height/2)*(256)+(fighter.screenCol + 2))] == 0
                && !collisionMapBitmap[((fighter.screenRow + fighter.height - 1)*(256)+(fighter.screenCol + 2))] == 0)
                {
                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                     door1Collision(0);
                    door2Collision(0);
                    leverCollision();
                    if(fighter.screenCol> 0){
                        fighter.screenCol--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
        if(!collisionMapBitmap[((fighter.screenRow + 5)*(256)+(fighter.screenCol + fighter.width - 1))] == 0
        && !collisionMapBitmap[((fighter.screenRow + fighter.height/2)*(256)+(fighter.screenCol + fighter.width - 1))] == 0
                && !collisionMapBitmap[((fighter.screenRow + fighter.height - 1)*(256)+(fighter.screenCol + fighter.width - 1))] == 0)
                {
                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    chestCollision();
                    if(fighter.screenCol< 240){
                        fighter.screenCol++;
                    }
                }
         }

}


void moveShooter(){
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6)))){
        if(!collisionMapBitmap[((shooter.screenRow + 4)*(256)+(shooter.screenCol + 5))] == 0
            && !collisionMapBitmap[((shooter.screenRow + 4)*(256)+(shooter.screenCol + shooter.width/2 + 3))] == 0
                && !collisionMapBitmap[((shooter.screenRow + 4)*(256)+(shooter.screenCol + shooter.width - 1))] == 0)
                {

                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    if(shooter.screenRow > 0){
                        shooter.screenRow--;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<7)))){
        if(!collisionMapBitmap[((shooter.screenRow + shooter.height)*(256)+(shooter.screenCol + 5))] == 0
            && !collisionMapBitmap[((shooter.screenRow + shooter.height)*(256)+(shooter.screenCol + shooter.width/2 + 3))] == 0
                && !collisionMapBitmap[((shooter.screenRow + shooter.height)*(256)+(shooter.screenCol + shooter.width - 1))] == 0)
                {

                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    if(shooter.screenRow < 160 - shooter.height){
                        shooter.screenRow++;
                    }
                }
         }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
        if(!collisionMapBitmap[((shooter.screenRow + 5)*(256)+(shooter.screenCol + 4))] == 0
            && !collisionMapBitmap[((shooter.screenRow + shooter.height/2)*(256)+(shooter.screenCol + 4))] == 0
                && !collisionMapBitmap[((shooter.screenRow + shooter.height -1)*(256)+(shooter.screenCol + 4))] == 0)
                {

                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    leverCollision();
                    if(shooter.screenCol> 0){
                        shooter.screenCol--;
                    }
                }
         }
    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
        if(!collisionMapBitmap[((shooter.screenRow + 5)*(256)+(shooter.screenCol + shooter.width))] == 0
            && !collisionMapBitmap[((shooter.screenRow + shooter.height/2)*(256)+(shooter.screenCol + shooter.width))] == 0
                && !collisionMapBitmap[((shooter.screenRow + shooter.height - 1)*(256)+(shooter.screenCol + shooter.width))] == 0)
                {

                    if(!wall.active){
                        wallCollision();
                    }
                    if(!wall2.active){
                        wall2Collision();
                    }
                    door1Collision(0);
                    door2Collision(0);
                    chestCollision();
                    if(shooter.screenCol< 240){
                        shooter.screenCol++;
                    }
                }
         }
}



void actFighter()
{

    actionsFighter();


}

void actionsFighter(){
    if(fighter.aniState != IDLE){
        fighter.prevAniState = fighter.aniState;
        fighter.aniState = IDLE;
    }


    if(fighter.aniCounter % 20 == 0){
        fighter.currFrame++;
        fighter.currFrame %= 3;
    }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6))))
    {
        fighter.aniState = BACK;
        fighter.direction = F_UP;
    }


    if((~(*(volatile unsigned int *)0x04000130) & ((1<<7))))
    {
        fighter.aniState = FRONT;
        fighter.direction = F_DOWN;
    }


    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
        fighter.aniState = LEFT;
        fighter.direction = F_LEFT;
    }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
        fighter.aniState = RIGHT;
        fighter.direction = F_RIGHT;
    }

    if((!(~(oldButtons)&((1<<0))) && (~buttons & ((1<<0))))){

        ifAttack = 1;
        if(which == 0 && dontPunch == 0){
            playSoundB(PunchSfx, 4041, 11025, 0);
        }
        if(which == 0){
                if(wall.isHit == 1){
                    wall.active = 1;

            }

                if(wall2.isHit == 1){
                    wall2.active = 1;
            }
        }



    }

    if(fighter.aniState == IDLE){
        fighter.currFrame = 0;
        fighter.aniState = fighter.prevAniState;
    }

    if(fighter.aniState != IDLE){
        fighter.aniCounter++;
    }
}


void actShooter()
{

    actionsShooter();



}

void actionsShooter(){

    shooter.width = 11;
    shooter.height = 15;

    if(shooter.aniState != IDLE){
        shooter.prevAniState = shooter.aniState;
        shooter.aniState = IDLE;
    }

    if(shooter.aniCounter % 20 == 0){
        shooter.currFrame++;
        shooter.currFrame %= 3;
    }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<6))))
    {
        shooter.aniState = BACK;
        shooter.direction = S_UP;
    }


    if((~(*(volatile unsigned int *)0x04000130) & ((1<<7))))
    {
        shooter.aniState = FRONT;
        shooter.direction = S_DOWN;
    }



    if((~(*(volatile unsigned int *)0x04000130) & ((1<<5)))){
        shooter.aniState = LEFT;
        shooter.direction = S_LEFT;
    }

    if((~(*(volatile unsigned int *)0x04000130) & ((1<<4)))){
        shooter.aniState = RIGHT;
        shooter.direction = S_RIGHT;
    }

    if((!(~(oldButtons)&((1<<0))) && (~buttons & ((1<<0))))){
        ifAttack = 1;
        if(which == 1){
            playSoundB(LaserSfx, 3007, 11025, 0);
        }
    }

    if(chest.isHit == 1 && which == 1){
        if((!(~(oldButtons)&((1<<1))) && (~buttons & ((1<<1))))){
                ifOpenChest = 1;
                chest.active = 1;
                withKey = 1;
                if(isChestOpen == 0){
                    playSoundB(OpenSfx, 5675, 11025, 0);
                    isChestOpen = 1;

                }
            }
        }


    if(lever.isHit == 1 && chest.active == 1 && withKey == 1 && isChestOpen == 1){
        if((!(~(oldButtons)&((1<<1))) && (~buttons & ((1<<1))))){
            lever.active = 1;
            withKey = 0;
            doorExit.active = 1;
            doorExit.width = 4;

            if(greenDoorOpened == 0){
                playSoundB(DoorSfx, 3925, 11025, 0);
                greenDoorOpened = 1;
                shooter.height = 15;
                shooter.width = 8;
            }
        }


    }




    if(shooter.aniState == IDLE){
        shooter.currFrame = 0;
        shooter.aniState = shooter.prevAniState;
    }

    if(shooter.aniState != IDLE){
        shooter.aniCounter++;
    }
}


void movePBullets(int tutLevel){
    if(which == 1){
        if((!(~(oldButtons)&((1<<0))) && (~buttons & ((1<<0))))){
            for(int i = 0; i<bulletCount; i++){
                if(!pBullets[i].active){
                    if(shooter.direction == S_RIGHT){
                        pBullets[i].cdel = 1;
                        pBullets[i].rdel = 0;
                        pBullets[i].direction = bullet_h;
                        pBullets[i].screenRow = shooter.screenRow + 3;
                        pBullets[i].screenCol = shooter.screenCol + 8;
                    }
                    if(shooter.direction == S_LEFT){
                        pBullets[i].cdel = -1;
                        pBullets[i].rdel = 0;
                        pBullets[i].direction = bullet_h;
                        pBullets[i].screenRow = shooter.screenRow + 3;
                        pBullets[i].screenCol = shooter.screenCol + 2;
                    }
                    if(shooter.direction == S_UP){
                        pBullets[i].rdel = -1;
                        pBullets[i].cdel = 0;
                        pBullets[i].direction = bullet_v;
                        pBullets[i].screenRow = shooter.screenRow + 3;
                        pBullets[i].screenCol = shooter.screenCol + 8;
                    }
                    if(shooter.direction == S_DOWN){
                        pBullets[i].rdel = 1;
                        pBullets[i].cdel = 0;
                        pBullets[i].direction = bullet_v;
                        pBullets[i].screenRow = shooter.screenRow + 3;
                        pBullets[i].screenCol = shooter.screenCol + 2;
                    }

                    pBullets[i].active = 1;

                    break;
                }
            }
        }
    }



    for(int i = 0; i<bulletCount; i++){
        if(pBullets[i].active){
            if(pBullets[i].cdel > 0){

                if(tutLevel == 6){
                    pBullets[i].screenCol += 1;
                    if(pBullets[i].screenCol == 240){
                        pBullets[i].active = 0;
                    }
                }else if(tutLevel == 10){
                         if(pBullets[i].screenCol != 240 && !collisionMap2Bitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol))] == 0
                        && !collisionMap2Bitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol + pBullets[i].width/2))] == 0
                        && !collisionMap2Bitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol + pBullets[i].width))] == 0){
                        pBullets[i].screenCol += 1;

                    }else{
                        pBullets[i].active = 0;
                    }
                }else{
                       if(pBullets[i].screenCol != 240 && !collisionMapBitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol))] == 0
                    && !collisionMapBitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol + pBullets[i].width/2))] == 0
                    && !collisionMapBitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol + pBullets[i].width))] == 0){
                        pBullets[i].screenCol += 1;

                    }else{
                        pBullets[i].active = 0;
                    }
                }

            }
            if(pBullets[i].cdel < 0){

                if(tutLevel == 6){
                    pBullets[i].screenCol -= 1;
                    if(pBullets[i].screenCol == 0 - pBullets[i].width){
                        pBullets[i].active = 0;
                    }
                }else if(tutLevel == 10){
                     if(pBullets[i].screenCol != 0 && !collisionMap2Bitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol))] == 0
                        && !collisionMap2Bitmap[((pBullets[i].screenRow + pBullets[i].height/2)*(256)+(pBullets[i].screenCol))] == 0
                        && !collisionMap2Bitmap[((pBullets[i].screenRow + pBullets[i].height -1)*(256)+(pBullets[i].screenCol))] == 0){

                        pBullets[i].screenCol-=1;
                    }else{
                        pBullets[i].active = 0;
                    }
                }else{
                        if(pBullets[i].screenCol != 0 && !collisionMapBitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol))] == 0
                    && !collisionMapBitmap[((pBullets[i].screenRow + pBullets[i].height/2)*(256)+(pBullets[i].screenCol))] == 0
                    && !collisionMapBitmap[((pBullets[i].screenRow + pBullets[i].height -1)*(256)+(pBullets[i].screenCol))] == 0){

                        pBullets[i].screenCol-=1;
                    }else{
                        pBullets[i].active = 0;
                    }
                }

            }
            if(pBullets[i].rdel > 0){

                if(tutLevel == 6){
                    pBullets[i].screenRow+=1;
                    if(pBullets[i].screenRow == 160){
                        pBullets[i].active = 0;
                    }

                }else if(tutLevel == 10){
                    if(pBullets[i].screenRow != 160 && !collisionMap2Bitmap[((pBullets[i].screenRow + pBullets[i].height)*(256)+(pBullets[i].screenCol))] == 0
                    && !collisionMap2Bitmap[((pBullets[i].screenRow + pBullets[i].height)*(256)+(pBullets[i].screenCol + pBullets[i].width/2))] == 0
                    && !collisionMap2Bitmap[((pBullets[i].screenRow + pBullets[i].height)*(256)+(pBullets[i].screenCol + pBullets[i].width))] == 0){
                        pBullets[i].screenRow+=1;
                    }else{
                        pBullets[i].active = 0;
                    }
                }else{
                        if(pBullets[i].screenRow != 160 && !collisionMapBitmap[((pBullets[i].screenRow + pBullets[i].height)*(256)+(pBullets[i].screenCol))] == 0
                    && !collisionMapBitmap[((pBullets[i].screenRow + pBullets[i].height)*(256)+(pBullets[i].screenCol + pBullets[i].width/2))] == 0
                    && !collisionMapBitmap[((pBullets[i].screenRow + pBullets[i].height)*(256)+(pBullets[i].screenCol + pBullets[i].width))] == 0){
                        pBullets[i].screenRow+=1;
                    }else{
                        pBullets[i].active = 0;
                    }
                }

            }
            if(pBullets[i].rdel < 0 ){

                if(tutLevel == 6){
                    pBullets[i].screenRow-=1;
                    if(pBullets[i].screenRow == 0){
                        pBullets[i].active = 0;
                    }
                }else if(tutLevel == 10){
                    if(pBullets[i].screenRow != 0 && !collisionMap2Bitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol))] == 0
                    && !collisionMap2Bitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol + pBullets[i].width/2))] == 0
                    && !collisionMap2Bitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol + pBullets[i].width))] == 0){

                        pBullets[i].screenRow-=1;

                    }else{
                        pBullets[i].active = 0;
                    }
                }else{
                        if(pBullets[i].screenRow != 0 && !collisionMapBitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol))] == 0
                    && !collisionMapBitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol + pBullets[i].width/2))] == 0
                    && !collisionMapBitmap[((pBullets[i].screenRow)*(256)+(pBullets[i].screenCol + pBullets[i].width))] == 0){

                        pBullets[i].screenRow-=1;

                    }else{
                        pBullets[i].active = 0;
                    }
                 }
             }

        }
    }


    for(int i = 0; i<bulletCount; i++){
        if(pBullets[i].active){
            if(tutLevel != 6){
                    if(orb1.active){
                        if(pBullets[i].screenCol < orb1.screenCol + orb1.width - 1 &&
                            pBullets[i].screenCol + pBullets[i].width -1 > orb1.screenCol &&
                            pBullets[i].screenRow < orb1.screenRow + orb1.height -1 &&
                            pBullets[i].screenRow + pBullets[i].height - 1> orb1.screenRow){

                            orb1.lives--;
                            if(orb1.lives == 0){
                                orb1.active = 0;
                                playSoundB(DestroySfx, 24236, 11025, 0);
                            }
                            pBullets[i].active = 0;
                    }
                }
            }


            if(orb2.active){
                if(pBullets[i].screenCol < orb2.screenCol + orb2.width - 1 &&
                    pBullets[i].screenCol + pBullets[i].width - 1> orb2.screenCol &&
                    pBullets[i].screenRow < orb2.screenRow + orb2.height -1 &&
                    pBullets[i].screenRow + pBullets[i].height - 1 > orb2.screenRow){

                    orb2.lives--;
                    if(orb2.lives == 0){
                        orb2.active = 0;
                        playSoundB(DestroySfx, 24236, 11025, 0);
                    }
                    pBullets[i].active = 0;
                }
            }

        }

    }
}


void moveTBullets(){
    if(!(++time % timeToNextTBullet)){

        for(int i = 0; i< 7; i++){
            if(!tBullets[i].active){
                tBullets[i].screenCol = 0;
                tBullets[i].screenRow = 0;
                tBullets[i].cdel = -1;
                tBullets[i].direction = tbullet_v;

                break;
            }
        }
        for(int i = 7; i < 14; i++){
            if(!tBullets[i].active){

                tBullets[i].screenCol = 210;
                tBullets[i].screenRow = 61;
                tBullets[i].cdel = -1;
                tBullets[i].direction = tbullet_h;
                tBullets[i].active = 1;

                break;
            }
        }
        for(int i = 14; i < 21; i++){
            if(!tBullets[i].active){

                tBullets[i].screenCol = 161;
                tBullets[i].screenRow = 85;
                tBullets[i].cdel = 1;
                tBullets[i].direction = tbullet_h;
                 tBullets[i].active = 1;


                break;
            }
        }
        for(int i = 21; i < 28; i++){
            if(!tBullets[i].active){

                tBullets[i].screenCol = 65;
                tBullets[i].screenRow = 71;
                tBullets[i].cdel = -1;
                tBullets[i].direction = tbullet_h;
                 tBullets[i].active = 1;


                break;
            }
        }
        for(int i = 28; i < 35; i++){
            if(!tBullets[i].active){

                tBullets[i].screenCol = 61;
                tBullets[i].screenRow = 18;
                tBullets[i].rdel = 1;
                tBullets[i].direction = tbullet_v;
                tBullets[i].active = 1;


                break;
            }
        }
        timeToNextTBullet = rand()%25 + 125;
    }



    for(int i = 7; i < tBulletCount; i++){
        if(tBullets[i].active){
            tBullets[i].screenCol += tBullets[i].cdel;

            if(i >= 7 && i <= 14){
                if(tBullets[i].screenCol == 153){
                    tBullets[i].active = 0;
                }
            }

            if(tBullets[i].screenCol == 5 || tBullets[i].screenCol == 230 || playerBulletCollision(tBullets[i].screenRow, tBullets[i].screenCol, tBullets[i].width, tBullets[i].height,
                fighter.screenCol, fighter.screenRow, fighter.width, fighter.height)){
                tBullets[i].active = 0;
            }
            tBullets[i].screenRow += tBullets[i].rdel;
            if(tBullets[i].screenRow == 5 || tBullets[i].screenRow == 150 || playerBulletCollision(tBullets[i].screenRow, tBullets[i].screenCol, tBullets[i].width, tBullets[i].height,
                shooter.screenCol, shooter.screenRow, shooter.width, shooter.height)){
                tBullets[i].active = 0;
            }
        }
    }
}

void moveT2Bullets(){
    if(!(++time % timeToNextTBullet)){

        for(int i = 0; i< 7; i++){
            if(!tBullets[i].active){
                tBullets[i].screenCol = 0;
                tBullets[i].screenRow = 0;
                tBullets[i].cdel = -1;
                tBullets[i].direction = tbullet_v;

                break;
            }
        }
        for(int i = 7; i < 14; i++){
            if(!tBullets[i].active){

                tBullets[i].screenCol = 232;
                tBullets[i].screenRow = 140;
                tBullets[i].cdel = -1;
                tBullets[i].direction = tbullet_h;
                tBullets[i].active = 1;

                break;
            }
        }
        for(int i = 14; i < 21; i++){
            if(!tBullets[i].active){

                tBullets[i].screenCol = 169;
                tBullets[i].screenRow = 10;
                tBullets[i].rdel = 1;
                tBullets[i].direction = tbullet_v;
                 tBullets[i].active = 1;


                break;
            }
        }
        for(int i = 21; i < 28; i++){
            if(!tBullets[i].active){

                tBullets[i].screenCol = 5;
                tBullets[i].screenRow = 80;
                tBullets[i].rdel = 1;
                tBullets[i].direction = tbullet_v;
                 tBullets[i].active = 1;

                break;
            }
        }
        for(int i = 28; i < 35; i++){
            if(!tBullets[i].active){

                tBullets[i].screenCol = 5;
                tBullets[i].screenRow = 110;
                tBullets[i].cdel = 1;
                tBullets[i].direction = tbullet_h;
                tBullets[i].active = 1;

                break;
            }
        }
        timeToNextTBullet = rand()%25 + 125;
    }



    for(int i = 7; i < tBulletCount; i++){
        if(tBullets[i].active){
            tBullets[i].screenCol += tBullets[i].cdel;

            if(i >= 7 && i < 14){
                if(tBullets[i].screenCol == 140){
                    tBullets[i].active = 0;
                }
            }

            if(i >= 14 && i < 28){
                if(tBullets[i].screenRow == 82){
                    tBullets[i].active = 0;
                }
            }


            if(i >= 28 && i < 35){
                if(tBullets[i].screenCol == 75){
                    tBullets[i].active = 0;
                }
            }

            if(tBullets[i].screenCol == 5 || tBullets[i].screenCol == 230 || playerBulletCollision(tBullets[i].screenRow, tBullets[i].screenCol, tBullets[i].width, tBullets[i].height,
                fighter.screenCol, fighter.screenRow, fighter.width, fighter.height)){
                tBullets[i].active = 0;
            }
            tBullets[i].screenRow += tBullets[i].rdel;
            if(tBullets[i].screenRow == 5 || tBullets[i].screenRow == 150 || playerBulletCollision(tBullets[i].screenRow, tBullets[i].screenCol, tBullets[i].width, tBullets[i].height,
                shooter.screenCol, shooter.screenRow, shooter.width, shooter.height)){
                tBullets[i].active = 0;
            }
        }
    }
}


void moveOrb1(){
    if(orb1.direction == E_RIGHT){
        orb1.screenCol += orb1.cdel;
    }else if(orb1.direction == E_UP){
        orb1.screenRow -= orb1.rdel;
    }else if(orb1.direction == E_LEFT){
        orb1.screenCol -= orb1.cdel;
    }else if(orb1.direction == E_DOWN){
        orb1.screenRow += orb1.rdel;
    }



    if(orb1.stateCount % 30 == 0){
        orb1.state++;
        orb1.state %= 4;
    }
    if(orb1.screenCol <= 60 && orb1.screenRow > 130 && orb1.direction == E_DOWN){
        orb1.screenCol = 60;
        orb1.screenRow = 130;
        orb1.direction = E_RIGHT;
    }
    if(orb1.screenCol > 160 && orb1.screenRow >= 130 && orb1.direction == E_RIGHT){
        orb1.screenCol = 160;
        orb1.screenRow = 130;
        orb1.direction = E_UP;
    }
    if(orb1.screenCol >= 160 && orb1.screenRow < 100 && orb1.direction == E_UP){
        orb1.screenCol = 160;
        orb1.screenRow = 100;
        orb1.direction = E_LEFT;
    }
    if(orb1.screenCol < 60 && orb1.screenRow <= 100 && orb1.direction == E_LEFT){
        orb1.screenCol = 60;
        orb1.screenRow = 100;
        orb1.direction = E_DOWN;
    }
    if(orb1.active){
       playerObjectCollision(orb1.screenRow, orb1.screenCol, orb1.width, orb1.height,
        fighter.screenRow, fighter.screenCol, fighter.width, fighter.height);
       playerObjectCollision(orb1.screenRow, orb1.screenCol, orb1.width, orb1.height,
        shooter.screenRow, shooter.screenCol, shooter.width, shooter.height);

    }


}

void moveOrb2(){
    if(orb2.direction == E_RIGHT){
        orb2.screenCol += orb2.cdel;
    }else if(orb2.direction == E_LEFT){
        orb2.screenCol -= orb2.cdel;
    }


    if(orb2.stateCount % 30 == 0){

        orb2.state++;
        orb2.state %= 4;
    }

    if(orb2.screenCol < 150){
        orb2.screenCol = 150;
        orb2.direction = E_RIGHT;
    }
    if(orb2.screenCol > 200){
        orb2.screenCol = 200;
        orb2.direction = E_LEFT;
    }
    if(orb2.active){
        playerObjectCollision(orb2.screenRow, orb2.screenCol, orb2.width, orb2.height,
            fighter.screenRow, fighter.screenCol, fighter.width, fighter.height);
        playerObjectCollision(orb2.screenRow, orb2.screenCol, orb2.width, orb2.height,
            shooter.screenRow, shooter.screenCol, shooter.width, shooter.height);

    }


}

void moveBlock(){
    if(block.screenCol < fighter.screenCol + fighter.width - 2 &&
        block.screenCol + block.width > fighter.screenCol &&
        block.screenRow < fighter.screenRow + fighter.height - 2 &&
        block.screenRow + block.height > fighter.screenRow ){

            withBlock = 1;
            dontPunch = 1;
            ifAttack = 0;
            if(fighter.direction == F_RIGHT){
                if(withBlock == 1){
                    fighter.width = 18;
                }

                if(!collisionMapBitmap[((block.screenRow + 3)*(256)+(block.screenCol + block.width - 1))] == 0
                && !collisionMapBitmap[((block.screenRow -1 + block.height/2)*(256)+(block.screenCol + block.width - 1))] == 0
                && !collisionMapBitmap[((block.screenRow - 4 + block.height)*(256)+(block.screenCol + block.width - 1))] == 0)
                {


                    block.screenCol++;
                }else{

                    fighter.screenCol--;
                }

            }else if(fighter.direction == F_LEFT){
                if(withBlock == 1){
                    block.width = 10;
                }

                if(!collisionMapBitmap[((block.screenRow + 3)*(256)+(block.screenCol + 1))] == 0
                && !collisionMapBitmap[((block.screenRow - 1 + block.height/2)*(256)+(block.screenCol + 1))] == 0
                && !collisionMapBitmap[((block.screenRow - 4 + block.height)*(256)+(block.screenCol + 1))] == 0)
                { block.screenCol--;
                }else{

                    fighter.screenCol++;

                }
            }else if(fighter.direction == F_UP){
                if(!collisionMapBitmap[((block.screenRow + 1)*(256)+(block.screenCol + 1))] == 0
                && !collisionMapBitmap[((block.screenRow + 1)*(256)+(block.screenCol + block.width/2 - 1))] == 0
                && !collisionMapBitmap[((block.screenRow + 1)*(256)+(block.screenCol + block.width - 1))] == 0)
                {block.screenRow--;
                }else{

                    fighter.screenRow++;
                }
            }else{
                if(!collisionMapBitmap[((block.screenRow + block.height - 2)*(256)+(block.screenCol + 1))] == 0
                && !collisionMapBitmap[((block.screenRow + block.height - 2)*(256)+(block.screenCol + block.width/2 - 1))] == 0
                && !collisionMapBitmap[((block.screenRow + block.height - 2)*(256)+(block.screenCol + block.width - 1))] == 0)
                {block.screenRow++;
                }else{

                    fighter.screenRow--;
                }
            }

    }else{
        dontPunch = 0;

    }

     if(block.screenCol < button.screenCol + button.width &&
        block.screenCol + block.width > button.screenCol &&
        block.screenRow < button.screenRow + button.height &&
        block.screenRow + button.height > button.screenRow ){

            button.active = 1;
            doorA.active = 1;
            doorA.width = 4;

           if(which == 0 && blueDoorOpened == 0){
                playSoundB(DoorSfx, 3925, 11025, 0);
                blueDoorOpened = 1;
            }


     }


}

void moveBlockTut4(){
    if(block.screenCol < fighter.screenCol + fighter.width - 2 &&
        block.screenCol + block.width > fighter.screenCol &&
        block.screenRow < fighter.screenRow + fighter.height - 2 &&
        block.screenRow + block.height > fighter.screenRow ){

            withBlock = 1;
            dontPunch = 1;
            ifAttack = 0;
            if(fighter.direction == F_RIGHT){
                if(withBlock == 1){
                    fighter.width = 15;
                }

                if(!collisionMapTut4Bitmap[((block.screenRow + 3)*(256)+(block.screenCol + block.width - 1))] == 0
                && !collisionMapTut4Bitmap[((block.screenRow -1 + block.height/2)*(256)+(block.screenCol + block.width - 1))] == 0
                && !collisionMapTut4Bitmap[((block.screenRow - 4 + block.height)*(256)+(block.screenCol + block.width - 1))] == 0)
                {


                    block.screenCol++;
                }else{

                    fighter.screenCol--;
                }

            }else if(fighter.direction == F_LEFT){
                if(withBlock == 1){
                    block.width = 10;
                }

                if(!collisionMapTut4Bitmap[((block.screenRow + 3)*(256)+(block.screenCol + 1))] == 0
                && !collisionMapTut4Bitmap[((block.screenRow - 1 + block.height/2)*(256)+(block.screenCol + 1))] == 0
                && !collisionMapTut4Bitmap[((block.screenRow - 4 + block.height)*(256)+(block.screenCol + 1))] == 0)
                { block.screenCol--;
                }else{

                    fighter.screenCol++;

                }
            }else if(fighter.direction == F_UP){
                if(!collisionMapTut4Bitmap[((block.screenRow + 1)*(256)+(block.screenCol + 1))] == 0
                && !collisionMapTut4Bitmap[((block.screenRow + 1)*(256)+(block.screenCol + block.width/2 - 1))] == 0
                && !collisionMapTut4Bitmap[((block.screenRow + 1)*(256)+(block.screenCol + block.width - 1))] == 0)
                {block.screenRow--;
                }else{

                    fighter.screenRow++;
                }
            }else{
                if(!collisionMapTut4Bitmap[((block.screenRow + block.height - 2)*(256)+(block.screenCol + 1))] == 0
                && !collisionMapTut4Bitmap[((block.screenRow + block.height - 2)*(256)+(block.screenCol + block.width/2 - 1))] == 0
                && !collisionMapTut4Bitmap[((block.screenRow + block.height - 2)*(256)+(block.screenCol + block.width - 1))] == 0)
                {block.screenRow++;
                }else{

                    fighter.screenRow--;
                }
            }

    }else{
        dontPunch = 0;

    }

     if(block.screenCol < button.screenCol + button.width &&
        block.screenCol + block.width > button.screenCol &&
        block.screenRow < button.screenRow + button.height &&
        block.screenRow + button.height > button.screenRow ){

            button.active = 1;
            doorA.active = 1;
            doorA.width = 4;

           if(which == 0 && blueDoorOpened == 0){
                playSoundB(DoorSfx, 3925, 11025, 0);
                blueDoorOpened = 1;
            }
      }
}

void moveBlockGame2(){
    if(block.screenCol < fighter.screenCol + fighter.width - 2 &&
        block.screenCol + block.width > fighter.screenCol &&
        block.screenRow < fighter.screenRow + fighter.height - 2 &&
        block.screenRow + block.height > fighter.screenRow ){

            withBlock = 1;
            dontPunch = 1;
            ifAttack = 0;
            if(fighter.direction == F_RIGHT){
                if(withBlock == 1){
                    fighter.width = 18;
                }

                if(!collisionMap2Bitmap[((block.screenRow + 3)*(256)+(block.screenCol + block.width - 1))] == 0
                && !collisionMap2Bitmap[((block.screenRow -1 + block.height/2)*(256)+(block.screenCol + block.width - 1))] == 0
                && !collisionMap2Bitmap[((block.screenRow - 4 + block.height)*(256)+(block.screenCol + block.width - 1))] == 0)
                {


                    block.screenCol++;
                }else{

                    fighter.screenCol--;
                }

            }else if(fighter.direction == F_LEFT){
                if(withBlock == 1){
                    block.width = 10;
                }

                if(!collisionMap2Bitmap[((block.screenRow + 3)*(256)+(block.screenCol + 1))] == 0
                && !collisionMap2Bitmap[((block.screenRow - 1 + block.height/2)*(256)+(block.screenCol + 1))] == 0
                && !collisionMap2Bitmap[((block.screenRow - 4 + block.height)*(256)+(block.screenCol + 1))] == 0)
                { block.screenCol--;
                }else{

                    fighter.screenCol++;

                }
            }else if(fighter.direction == F_UP){
                if(!collisionMap2Bitmap[((block.screenRow + 1)*(256)+(block.screenCol + 1))] == 0
                && !collisionMap2Bitmap[((block.screenRow + 1)*(256)+(block.screenCol + block.width/2 - 1))] == 0
                && !collisionMap2Bitmap[((block.screenRow + 1)*(256)+(block.screenCol + block.width - 1))] == 0)
                {block.screenRow--;
                }else{

                    fighter.screenRow++;
                }
            }else{
                if(!collisionMap2Bitmap[((block.screenRow + block.height - 2)*(256)+(block.screenCol + 1))] == 0
                && !collisionMap2Bitmap[((block.screenRow + block.height - 2)*(256)+(block.screenCol + block.width/2 - 1))] == 0
                && !collisionMap2Bitmap[((block.screenRow + block.height - 2)*(256)+(block.screenCol + block.width - 1))] == 0)
                {block.screenRow++;
                }else{

                    fighter.screenRow--;
                }
            }

    }else{
        dontPunch = 0;

    }

     if(block.screenCol < button.screenCol + button.width &&
        block.screenCol + block.width > button.screenCol &&
        block.screenRow < button.screenRow + button.height &&
        block.screenRow + button.height > button.screenRow ){

            button.active = 1;
            doorA.active = 1;
            doorA.width = 4;

           if(which == 0 && blueDoorOpened == 0){
                playSoundB(DoorSfx, 3925, 11025, 0);
                blueDoorOpened = 1;
            }


     }
}

void moveOrb1Game2(){

}

void moveOrb2Game2(){

}


void door1Collision(int tutLevel){
    if(doorA.screenCol < fighter.screenCol + fighter.width - 1&&
        doorA.screenCol + doorA.width -1 > fighter.screenCol &&
        doorA.screenRow < fighter.screenRow + fighter.height - 1 &&
        doorA.screenRow + doorA.height - 1> fighter.screenRow ){

            if(tutLevel == 4){
                fighter.screenRow--;
            }else{
                fighter.screenRow++;
            }


    }


    if(doorA.screenCol < shooter.screenCol + shooter.width - 1&&
        doorA.screenCol + doorA.width -1 > shooter.screenCol &&
        doorA.screenRow < shooter.screenRow + shooter.height - 1&&
        doorA.screenRow + doorA.height - 1> shooter.screenRow ){
        if(tutLevel == 4){
                shooter.screenRow--;
            }else{
                shooter.screenRow++;
            }
    }


}

void door2Collision(int tutLevel){
    if(doorExit.screenCol < fighter.screenCol + fighter.width -1 &&
        doorExit.screenCol + doorExit.width - 1> fighter.screenCol &&
        doorExit.screenRow < fighter.screenRow + fighter.height -1 &&
        doorExit.screenRow + doorExit.height - 1> fighter.screenRow ){

            if(tutLevel == 7){
                fighter.screenRow++;

            }else{
                fighter.screenRow--;
            }
        }


    if(doorExit.screenCol < shooter.screenCol + shooter.width - 1 &&
        doorExit.screenCol + doorExit.width - 1> shooter.screenCol &&
        doorExit.screenRow < shooter.screenRow + shooter.height -1 &&
        doorExit.screenRow + doorExit.height - 1> shooter.screenRow ){

            if(tutLevel == 7){
                shooter.screenRow++;
            }else{
                shooter.screenRow--;
            }

    }
}

void wallCollision(){
    if(wall.screenCol < fighter.screenCol + fighter.width - 1 &&
        wall.screenCol + wall.width - 1> fighter.screenCol &&
        wall.screenRow < fighter.screenRow + fighter.height -1 &&
        wall.screenRow + wall.height - 1> fighter.screenRow ){
            fighter.screenRow++;
            if(which == 0){
                wall.isHit = 1;
            }


    }
    if(wall.screenCol < shooter.screenCol + shooter.width - 1&&
        wall.screenCol + wall.width - 1> shooter.screenCol &&
        wall.screenRow < shooter.screenRow + shooter.height - 1&&
        wall.screenRow + wall.height - 1> shooter.screenRow ){
            shooter.screenRow++;
    }

}

void wall2Collision(){
    if(wall2.screenCol < fighter.screenCol + fighter.width &&
        wall2.screenCol + wall2.width > fighter.screenCol &&
        wall2.screenRow < fighter.screenRow + fighter.height &&
        wall2.screenRow + wall2.height > fighter.screenRow ){

            fighter.screenCol--;


            if(which == 0){
             wall2.isHit = 1;
            }


    }
    if(wall2.screenCol < shooter.screenCol + shooter.width &&
        wall2.screenCol + wall2.width > shooter.screenCol &&
        wall2.screenRow < shooter.screenRow + shooter.height &&
        wall2.screenRow + wall2.height > shooter.screenRow ){

         shooter.screenCol--;

    }
}

void chestCollision(){


    if(chest.screenCol < fighter.screenCol + fighter.width - 1 &&
        chest.screenCol + chest.width -1 > fighter.screenCol &&
        chest.screenRow < fighter.screenRow + fighter.height - 1&&
        chest.screenRow + chest.height - 1> fighter.screenRow){
            fighter.screenCol--;
        }

    if(chest.screenCol < shooter.screenCol + shooter.width -1 &&
        chest.screenCol + chest.width - 1> shooter.screenCol &&
        chest.screenRow < shooter.screenRow + shooter.height - 1 &&
        chest.screenRow + chest.height - 1> shooter.screenRow ){

            shooter.screenCol--;
            if(which == 1){
                chest.isHit = 1;
            }

    }
}

void leverCollision(){
     if(lever.screenCol < fighter.screenCol + fighter.width &&
        lever.screenCol + lever.width > fighter.screenCol &&
        lever.screenRow < fighter.screenRow + fighter.height &&
        lever.screenRow + lever.height > fighter.screenRow){
            fighter.screenCol++;
        }

    if(lever.screenCol < shooter.screenCol + shooter.width &&
        lever.screenCol + lever.width > shooter.screenCol &&
        lever.screenRow < shooter.screenRow + shooter.height &&
        lever.screenRow + lever.height > shooter.screenRow ){

            shooter.screenCol++;
            if(which == 1 && withKey == 1){
                lever.isHit = 1;
            }

    }
}

int playerBulletCollision(int bulletRow, int bulletCol, int bWidth, int bHeight,
    int pCol, int pRow, int pWidth, int pHeight){



   if(bulletCol < pCol + pWidth - 1 &&
        bulletCol + bWidth - 1> pCol &&
        bulletRow < pRow + pHeight - 1 &&
        bulletRow + bHeight - 1 > pRow) {
            if(which == 1){
                shooter.lives--;
                playSoundB(DamageSfx, 5035, 11025, 0);
                shooter.isHit = 1;


            }else{
                fighter.lives--;
                playSoundB(DamageSfx, 5035, 11025, 0);
                fighter.isHit = 1;


            }

                return 1;
    }

      return 0;

}

int playerObjectCollision(int orbRow, int orbCol, int orbWidth, int orbHeight, int row, int col,int width, int height){

    if(orbCol < col + width -2 &&
        orbCol + orbWidth - 2 > col &&
        orbRow < row + height - 2 &&
        orbRow + orbHeight - 2 > row){

        if(which == 0){
            fighter.lives-=10;
        }else{
            shooter.lives-= 5;
        }

        return 1;
    }




    return 0;
}

int checkWin(){
    if(fighter.screenRow > 140 || shooter.screenRow > 140){
        return 1;
    }
    return 0;
}

int checkNoLives(){
    if(fighter.lives <= 0 || shooter.lives <= 0){
        return 1;
    }
    return 0;
}


void drawCharacters(){

    if(which == 1){
        drawShooter();
    }else{
        drawFighter();
    }




}

void drawEnemies(){
    drawOrb1();
    drawOrb2();
}

void drawObjects(){
    drawBlock();
    drawDoor1();
    drawDoor2();
    drawWall();
    drawWall2();
    drawChest();
    drawLever();
    drawButton();

}

void drawBullets(){
    drawPBullets();
    drawTBullets();
}

void drawFighter(){

    shadowOAM[1].attr0 = (2 << 8) | (0 << 13) | (0 << 14);
 shadowOAM[0].attr0 = (0xFF & fighter.screenRow) | (0 << 13) | (0 << 14);
 shadowOAM[0].attr1 = (1 << 14) | (0x1FF & (fighter.screenCol + 2));
    if(ifAttack == 1){
        shadowOAM[0].attr2 = (F_ATTACK)*32+(fighter.aniState*2);
        waitForVblank();
        ifAttack = 0;


    }else if(withBlock == 1){
        shadowOAM[0].attr2 = ((6 + fighter.currFrame*2))*32+(fighter.aniState*2);
        withBlock = 0;
        fighter.width = 11;
        fighter.height = 15;
        shooter.width = 8;
        shooter.height = 16;

    }else {
        shadowOAM[0].attr2 = (fighter.currFrame*2)*32+(fighter.aniState*2);
    }

}

void drawShooter(){

    shadowOAM[0].attr0 = (2 << 8) | (0 << 13) | (0 << 14);
    shadowOAM[1].attr0 = (0xFF & shooter.screenRow) | (0 << 13) | (0 << 14);
    shadowOAM[1].attr1 = (1 << 14) | (0x1FF & (shooter.screenCol+2));

    if(ifAttack == 1){
        shadowOAM[1].attr2 = (S_ATTACK)*32+(shooter.aniState*2);
        waitForVblank();
        ifAttack = 0;

    }else if(ifOpenChest == 1){
        shadowOAM[1].attr2 = (S_HACK)*32+(shooter.aniState*2);
        waitForVblank();
        ifOpenChest = 0;

    }else{
        shadowOAM[1].attr2 = (14 + (shooter.currFrame*2))*32+(shooter.aniState*2);
    }

}

void drawOrb1(){
    shadowOAM[2].attr0 = (0xFF & orb1.screenRow) | (0 << 13) | (0 << 14);
    shadowOAM[2].attr1 = (1 << 14) | (0x1FF & (orb1.screenCol));

    if(!orb1.active){
        shadowOAM[2].attr2 = (30)*32+(0);
    }else{
        shadowOAM[2].attr2 = (orb_loc)*32+(orb1.state*2);
    }
}

void drawOrb2(){
    shadowOAM[3].attr0 = (0xFF & orb2.screenRow) | (0 << 13) | (0 << 14);
    shadowOAM[3].attr1 = (1 << 14) | (0x1FF & (orb2.screenCol));
    if(!orb2.active){
        shadowOAM[3].attr2 = (30)*32+(0);
    }else{
        shadowOAM[3].attr2 = (orb_loc)*32+(orb2.state*2);
    }
}


void drawPBullets(){
    for(int i = 0; i<bulletCount; i++){
        if(!pBullets[i].active){
            shadowOAM[4 + i].attr0 = (2 << 8) | (0 << 13) | (0 << 14);
            shadowOAM[4 + i].attr1 = (0x1FF & pBullets[i].screenCol) |(1 << 14);
            shadowOAM[4 + i].attr2 = (bullet_loc)*32+(pBullets[i].direction);
        }
        else if(pBullets[i].active){
            shadowOAM[4 + i].attr0 = (0xFF & pBullets[i].screenRow) | (0 << 13) | (0 << 14);
            shadowOAM[4 + i].attr1 = (0x1FF & pBullets[i].screenCol) | (1 << 14);

            shadowOAM[4 + i].attr2 = (bullet_loc)*32+(pBullets[i].direction);
        }

    }
}

void drawTBullets(){
     for(int i = 0; i<tBulletCount; i++){
        if(!tBullets[i].active){
            shadowOAM[9 + i].attr0 = (2 << 8) | (0 << 13) | (0 << 14);
            shadowOAM[9 + i].attr1 = (0x1FF & tBullets[i].screenCol) | (1 << 14);
            shadowOAM[9 + i].attr2 = (bullet_loc)*32+(tBullets[i].direction);
        }
        else if(tBullets[i].active){
            shadowOAM[9 + i].attr0 = (0xFF & tBullets[i].screenRow) | (0 << 13) | (0 << 14);
            shadowOAM[9 + i].attr1 = (0x1FF & tBullets[i].screenCol) | (1 << 14);

            shadowOAM[9 + i].attr2 = (bullet_loc)*32+(tBullets[i].direction);
        }

    }
}

void drawBlock(){
    shadowOAM[46].attr0 = (0xFF & block.screenRow) | (0 << 13) | (0 << 14);
    shadowOAM[46].attr1 = (1 << 14) | (0x1FF & (block.screenCol));
    shadowOAM[46].attr2 = (blockButton_loc)*32+(blockloc);


}

void drawDoor1(){
    shadowOAM[47].attr0 = (0xFF & doorA.screenRow) | (0 << 13) | (1 << 14);
    shadowOAM[47].attr1 = (1 << 14)| (0x1FF & (doorA.screenCol));
    if(doorA.active == 1){
        shadowOAM[47].attr2 = (doorOpenRow)*32+(doorAloc);
    }else{
        shadowOAM[47].attr2 = (doorClosedRow)*32+(doorAloc);
    }

}

void drawDoor2(){
    shadowOAM[48].attr0 = (0xFF & doorExit.screenRow) | (0 << 13) | (1 << 14);
    shadowOAM[48].attr1 = (1 << 14)| (0x1FF & (doorExit.screenCol));

    if(doorExit.active == 1){
       shadowOAM[48].attr2 = (doorOpenRow)*32+(doorExitloc);
    }else{
        shadowOAM[48].attr2 = (doorClosedRow)*32+(doorExitloc);
    }
}

void drawWall(){
    shadowOAM[49].attr0 = (0xFF & wall.screenRow) | (0 << 13) | (1 << 14);
    shadowOAM[49].attr1 = (1 << 14)| (0x1FF & (wall.screenCol));

    if(wall.active == 1){
         shadowOAM[49].attr2 = (doorOpenRow)*32+(wallDown);
    }
    if(!wall.active){
        shadowOAM[49].attr2 = (doorClosedRow)*32+(wallOK);
    }



}

void drawWall2(){
    if(wall2.active == 1){
         shadowOAM[50].attr2 = (doorOpenRow)*32+(wallTwoDown);
    }
    if(!wall2.active){
        shadowOAM[50].attr2 = (doorClosedRow)*32+(wallTwoOk);
    }

    shadowOAM[50].attr0 = (0xFF & wall2.screenRow) | (0 << 13) | (2 << 14);
    shadowOAM[50].attr1 = (1 << 14)| (0x1FF & (wall2.screenCol));
}

void drawChest(){
    shadowOAM[51].attr0 = (0xFF & chest.screenRow) | (0 << 13) | (0 << 14);
    shadowOAM[51].attr1 = (1 << 14)| (0x1FF & (chest.screenCol));

    if(chest.active == 1){
        shadowOAM[51].attr2 = (onOffObjectLoc)*32+(chestOpen);
    }else{
        shadowOAM[51].attr2 = (onOffObjectLoc)*32+(chestClosed);
    }


}

void drawLever(){
    shadowOAM[52].attr0 = (0xFF & lever.screenRow) | (0 << 13) | (0 << 14);
    shadowOAM[52].attr1 = (1 << 14)| (0x1FF & (lever.screenCol));

    if(lever.active == 1 && chest.active == 1){
        shadowOAM[52].attr2 = (onOffObjectLoc)*32+(leverOn);
    }else{
        shadowOAM[52].attr2 = (onOffObjectLoc)*32+(leverOff);
    }

}

void drawButton(){
    shadowOAM[53].attr0 = (0xFF & button.screenRow) | (0 << 13) | (0 << 14);
    shadowOAM[53].attr1 = (1 << 14)| (0x1FF & (button.screenCol));

    if(button.active == 1){
        shadowOAM[53].attr2 = (blockButton_loc)*32+(buttonDown);

    }else{
        shadowOAM[53].attr2 = (blockButton_loc)*32+(buttonUp);
    }

}

void updateLives(){
    if(which == 0){
        shadowOAM[54].attr0 = (0xFF & livesNum.screenRow) | (0 << 13) | (0 << 14);
        shadowOAM[54].attr1 = (1 << 14)| (0x1FF & (livesNum.screenCol));
        shadowOAM[54].attr2 = (20)*32+((14 - fighter.lives)*2);

    }
    if(which == 1){
        shadowOAM[54].attr0 = (0xFF & livesNum.screenRow) | (0 << 13) | (0 << 14);
        shadowOAM[54].attr1 = (1 << 14)| (0x1FF & (livesNum.screenCol));
        shadowOAM[54].attr2 = (22)*32+((14 - shooter.lives)*2);

    }

}


void playSoundB( const unsigned char* sound, int length, int frequency, int loops) {

        dma[2].cnt = 0;

        int ticks = (16777216)/frequency;

        DMANow(2, sound, (void*)(0x040000A4), (2 << 21) | (3 << 28) | (1 << 25) | (1 << 26));

        *(volatile unsigned short*)0x4000106 = 0;

        *(volatile unsigned short*)0x4000104 = -ticks;
        *(volatile unsigned short*)0x4000106 = (1<<7);

        soundB.data = sound;
        soundB.length = length;
        soundB.frequency = frequency;
        soundB.loops = loops;
        soundB.isPlaying = 1;
        soundB.duration = (((59.727)*length)/frequency);
        soundB.vbCount = 0;

}
